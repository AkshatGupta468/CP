{
    "gakshat468 Boilerplate": {
    "prefix": "cp",
    "body": [
        "#include<bits/stdc++.h>",
        "using namespace std;",
        "#ifndef ONLINE_JUDGE",
        "#ifdef __linux__",
        "#include \"/media/gakshat468/New Volume/CP/algo/debug.h\"",
        "#elif _WIN32",
        "#include \"D:/CP/algo/debug.h\"",
        "#elif __APPLE__",
        "#include \"debug.h\"",
        "#endif",
        "#else",
        "#define debug(...) 468",
        "#endif",
        "#define MOD 1000000007",
        "#define nl <<'\\n'",
        "#define sp <<\" \"<<",
        "#define spe <<\" \"",
        "#define display_vec(a) for(auto i:a)cout<<i<<\" \"; cout <<\"\\n\";",
        "#define fast_io ios_base::sync_with_stdio(false); cin.tie(NULL)",
        "#define ll long long",
        "bool solve()",
        "{",
        "    int n;",
        "    cin >> n;",
        "    vector<int> a(n);",
        "    for (int i = 0;i < a.size();i++) {",
        "        cin >> a[i];",
        "    }",
        "    return true;",
        "}",
        "",
        "int32_t main()",
        "{",
        "    fast_io;",
        "#ifdef __linux__",
        "    string path = \"/media/gakshat468/New Volume/CP/\";",
        "#elif _WIN32",
        "    string path = \"D:/CP/\";",
        "#elif __APPLE__",
        "    string path = \"~/CP/\";",
        "#endif",
        "#ifndef ONLINE_JUDGE",
        "    freopen((path + \"input.txt\").c_str(), \"r\", stdin);",
        "    freopen((path + \"output.txt\").c_str(), \"w\", stdout);",
        "    freopen((path + \"error.txt\").c_str(), \"w\", stderr);",
        "#endif",
        "    int t = 1;",
        "    cin >> t;",
        "    while (t--) {",
        "        solve();",
        "        // cout << (solve() ? \"YES\\n\" : \"NO\\n\");",
        "        // cout << (solve() ? \"\" : \"-1\\n\");",
        "    }",
        "}",
        ""
    ],
    "description": "gakshat468 Boilerplate"
    },
    "Segment Tree with Lazy Propagation": {
        "prefix": "segtree",
        "body": [
            "struct  obj",
            "{",
            "    ll val;",
            "    obj(ll tval) {",
            "        val = tval;",
            "    }",
            "    obj() {",
            "        val = 0;",
            "    }",
            "};",
            "obj combine(const obj& lval, const obj& rval)",
            "{",
            "    return (lval.val + rval.val);",
            "}",
            "enum lazytype {",
            "    LAZY_NONE,",
            "    LAZY_INCREASE,",
            "    LAZY_SETVAL",
            "};",
            "struct lazyobj {",
            "    ll value = 0;",
            "    lazytype cmdtype = LAZY_NONE;",
            "};",
            "void fixindexing(int& a, int& b) {",
            "    --a;",
            "    --b;",
            "}",
            "void fixindexing(int& k) {",
            "    k--;",
            "}",
            "class segmenttree",
            "{",
            "public:",
            "    obj nullval;",
            "    void propagatecommand(lazyobj& updatethis, const lazyobj& refrlazy) {",
            "        switch (refrlazy.cmdtype)",
            "        {",
            "        case LAZY_NONE:",
            "            break;",
            "        case LAZY_SETVAL:",
            "            updatethis.value = refrlazy.value;",
            "            updatethis.cmdtype = LAZY_SETVAL;",
            "            break;",
            "        case LAZY_INCREASE:",
            "            updatethis.value += refrlazy.value;",
            "            if (updatethis.cmdtype == LAZY_NONE)",
            "                updatethis.cmdtype = refrlazy.cmdtype;",
            "            break;",
            "        }",
            "    }",
            "    int n;",
            "    vector<obj> tree;",
            "    vector<obj> arr;",
            "    vector<lazyobj> lazytree;",
            "    void resolve(int v, int l, int r) {",
            "        switch (lazytree[v].cmdtype) {",
            "        case LAZY_NONE:",
            "            break;",
            "        case LAZY_INCREASE:",
            "            tree[v].val += lazytree[v].value * (r - l + 1);",
            "            break;",
            "        case LAZY_SETVAL:",
            "            tree[v].val = lazytree[v].value * (r - l + 1);",
            "            break;",
            "        }",
            "        if (l == r) {",
            "            arr[l].val = tree[v].val;",
            "        }",
            "        else {",
            "            propagatecommand(lazytree[2 * v], lazytree[v]);",
            "            propagatecommand(lazytree[2 * v + 1], lazytree[v]);",
            "        }",
            "        lazytree[v].value = 0;",
            "        lazytree[v].cmdtype = LAZY_NONE;",
            "    }",
            "    void lazytreedisplay(int v, int l, int r) {",
            "        // cerr<<v sp l sp r nl<< lazytree[v].value sp lazytree[v].type nl;",
            "        if (l == r)return;",
            "        int mid = (l + r) / 2;",
            "        lazytreedisplay(2 * v, l, mid);",
            "        lazytreedisplay(2 * v + 1, mid + 1, r);",
            "    }",
            "    segmenttree(vector<obj>& tarr)",
            "    {",
            "        n = tarr.size();",
            "        tree.resize(4 * n + 1);",
            "        lazytree.resize(4 * n + 1);",
            "        arr = tarr;",
            "        build(1, 0, n - 1);",
            "    }",
            "    void build(int v, int l, int r)",
            "    {",
            "        if (l == r)",
            "        {",
            "            tree[v] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) / 2;",
            "        build(2 * v, l, mid);",
            "        build(2 * v + 1, mid + 1, r);",
            "        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
            "    }",
            "",
            "    void rangeupdate(int a, int b, lazyobj update) {",
            "        fixindexing(a, b);",
            "        if (a > b)return;",
            "        recrangeupdate(0, n - 1, a, b, 1, update);",
            "    }",
            "    void recrangeupdate(int l, int r, int a, int b, int v, lazyobj update) {",
            "        resolve(v, l, r);",
            "        //don't move this down ",
            "        //node needs to be updated even if it is out of range because ",
            "        // the ancestor nodes are dependent on this it can call a node",
            "        // which is out of range of a-b",
            "",
            "        //so ancestor wants all of its childs to be up-to-date as its value",
            "        //is dependent on children",
            "        if (r<a || l>b)",
            "            return;",
            "        // debug2(l,r);",
            "        if (a <= l && r <= b) {",
            "            propagatecommand(lazytree[v], update);",
            "            resolve(v, l, r);",
            "            return;",
            "        }",
            "        int mid = (l + r) / 2;",
            "        recrangeupdate(l, mid, a, b, 2 * v, update);",
            "        recrangeupdate(mid + 1, r, a, b, 2 * v + 1, update);",
            "        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
            "    }",
            "",
            "    obj rangequery(int a, int b)",
            "    {",
            "        fixindexing(a, b);",
            "        if (a > b) return nullval;",
            "        return recrangequery(0, n - 1, a, b, 1);",
            "    }",
            "    obj pointquery(int k) {",
            "        fixindexing(k);",
            "        return recrangequery(0, n - 1, k, k, 1);",
            "    }",
            "    obj recrangequery(int l, int r, int a, int b, int v)",
            "    {",
            "        resolve(v, l, r);",
            "        if (r<a || l>b)",
            "            return nullval;",
            "        if (a <= l && r <= b)",
            "            return tree[v];",
            "        int mid = (l + r) / 2;",
            "        return combine(recrangequery(l, mid, a, b, 2 * v), recrangequery(mid + 1, r, a, b, 2 * v + 1));",
            "    }",
            "};",
            ""
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "Dsu with path Compression": {
        "prefix": "dsu",
        "body": [
            "class dsu{",
            "    public:",
            "    vector<int> head;",
            "    vector<int> childs;",
            "    int n;",
            "    dsu(int n){",
            "        head.resize(n+1);",
            "        childs.resize(n+1);",
            "        this->n=n;",
            "        for(int i=1;i<=n;i++){",
            "            head[i]=i;",
            "            childs[i]=1;",
            "        }",
            "    }",
            "    int find(int x){",
            "        while(head[x]!=head[head[x]]){",
            "            head[x]=head[head[x]];",
            "        }",
            "        return head[x];",
            "    }",
            "    void unite(int x,int y){",
            "        x=find(x);",
            "        y=find(y);",
            "        if(x==y)return;",
            "        if(childs[x]>childs[y])swap(x,y);",
            "        head[x]=y;",
            "        childs[y]+=childs[x];",
            "    }",
            "};"
        ],
        "description": "Dsu with path Compression"
    },
    "Modular Exponentation": {
        "prefix": "Modular_Exponentiation",
        "body": [
            "int binaryExp(int a,int b,int M)",
            "{",
            "    int ans=1;",
            "    while(b>0)",
            "    {",
            "        if(b&1)",
            "        {",
            "            ans=(ans*1ll*a)%M;",
            "        }",
            "        a=(a*1ll*a)%M;",
            "        b>>=1;",
            "    }",
            "    return ans;",
            "}",
            ""
        ],
        "description": "Modular Exponentation"
    },
    "Linear sieve of Eratosthenes": {
        "prefix": "sieve_Eratosthenes",
        "body": [
            "vector<int> spf;",
            "void Linear_sieve()",
            "{",
            "    spf.resize(2e6);",
            "    int n = spf.size();",
            "    for (int i = 0;i < n;i++) spf[i] = i;",
            "    for (int i = 2;i * i <= n;i++)",
            "    {",
            "        for (int j = i * i;spf[i] == i && j < n;j += i)",
            "            spf[j] = min(i, spf[j]);",
            "    }",
            "}"
        ],
        "description": "Linear sieve of Eratosthenes"
    }
}
